from scipy import optimize
import numpy as np


def f(masiv):  # функция вернет точку минимума
    return (masiv[0] - 3.2) ** 2 + (masiv[1] - 0.1) ** 2 + 3


# print(f([3.2, 0.1]))

x_min = optimize.minimize(f, [5, 5])
# print(x_min)
# print(x_min.x)  # Обращение к полю x =>  вернет [3.19999896, 0.10000026]


"""
Есть и инструменты для работы с линейной алгреброй - например ( linalg )
"""
from scipy import linalg

matrix = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])  # задаваемая матрица
result = np.array([2, 4, -1])  # ответ который мы ожидаем
x = linalg.solve(matrix, result)  # ищем такой результат при котором,
#                            # если матрицу умножить на результат получится наш ожидаемый ответ
# print(x)  # [ 2. -2.  9.]

# for i in x:
#     print(i, end="|")

''' Проверка '''
# print(np.dot(matrix, x))  # [ 2.  4. -1.]

""" В модуле linalg есть разные операции для матричной разложении """
X = np.random.rand(4, 3)  # сгенерировали матрицу из случайных числе размером (4, 3)
U, D, V = linalg.svd(X)  # сделали разложение на три матрицы
print(U.shape, D.shape, V.shape)  # (4, 4) (3,) (3, 3)
# матрицы имеют размер (4, 4) / диагональная матрица = 3 / и матрица (3, 3)


